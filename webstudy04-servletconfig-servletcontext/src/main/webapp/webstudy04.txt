- 서블릿 계층 구조 Servlet Hierarchy
  최상위 인터페이스
  <<interface>>
  Servlet : init(), service(), destroy()와 같은 abstract method가 선언되어 있음
  설명 : 모든 자바 웹 프로그램은 Servlet Interface의 하위 클래스이다.
 
  위의 Servlet interface를 implements 하는 하위 Abstract class
  <<abstract class>>
  GenericServlet : 프로토콜에 독립적인 서버 프로그램을 위한 클래스
 				   일반적인 서버 차원에서 가져야 하는 기능을 자식에게 물려주고
 				   프로토콜에 특화된 자식 차원에서 구현해야 하는 service(request,response) 메서드는
 				   abstract method 선언해 구현을 강제한다(ex- 피자 서비스의 abstract topping 메서드)

  위의 abstract class 인 GenericServlet을 상속받는(extends) 하위 Abstract class가 존재
  <<abstract class>>
  HTTPServlet : Web Program을 위한 HTTP 프로토콜에 특화된 클래스
  				웹 서비스에 필요한 기능을 자식에게 물려준다
  				자바 웹 프로그램은 HTTPServlet을 상속받아야 한다
  				(모든 Servlet과 JSP : 예 - Spring의 DispatcherServlet 또한 HttpServlet 자식임)
				동작원리 -> 부모 GenericServlet의 abstract method인 service(request,response)를
				implements 구현하여 Web Container가 service 메서드를 호출하면
				구현한 service 메서드가 HttpRequest Method에 따라 개발자가 구현한
				doGet or doPost 등의 메서드로 dispatch(위임)하여 실행되고 응답된다.

- Form과 Servlet(or JSP)연동
  client
  <form action="처리할 서버 프로그램 url" method="get or post"> --request--> Web Server -- WebContainer -- MyServlet
  <input type="text" name="userId">														service 호출 --> service() --dispatch -> doGet() or doPost()
  <button type="submit">검색</button>													<--response--
	 
	 
 - Http Status Code(상태 코드)
 : 클라이언트(브라우저)와 서버(WAS)가 서로의 상태를 이해하는
   약속, HTTP 상태 코드는 세자리 숫자로 구성
   대표적인 Status code 상태코드
   200 OK : 요청이 성공적으로 처리됨. 가장 일반적인 성공 코드
   404 NotFound : 요청한 리소드를 서버에서 찾을수 없습니다.
   405 Method Not Allowed : 요청에 사용된 HTTP 메서드(get,post 등)가
   해당리소스(서버프로그램)에 대해허용되지 않음을 의미
   -> 만약 post 방식으로 클라이언트가 요청했는데 doGet()을 구현한 경우
   500 Internal Server Error : 서버에 예상치 못한 오류가 발생하여
   요청을 처리 할 수 없음을 나타냅니다. 가장 일반적인 서버 오류.
   
 **** 서블릿 아키텍쳐의 핵심 특징 ****
 자바 웹 응용 프로그램 개발자 - 표준 서블릿 API 계정 - WAS Vendor)
 			인터페이스 기반 개발					 인터페이스를 구현
 1. 표준화된 서블릿 API (인터페이스 기반 개발)
 	자바 웹 응용프로그램 개발자는 Servlet API(Servlet, ServletRequest, ServletResponse interface 등)
 	- jakarata EE(Java EE) 표준으로 정의된 인터페이스 기반으로 일관되게 웹 어플리케이션을 개발합니다.
 	이 표준화된 서블릿 API 덕분에 특정 WAS 제품에 종속되지 않고 일관된 방식으로 웹 어플리케이션을 구현할 수 있습니다.
 2. WAS(Web Application Server)의 구현 및 추상화
 	Apache Tomcat, JBoss, WebLogic, Jetty 등과 같은 WAS 제품들은 표준화된 Servlet API 인터페이스들을
 	각자의 방식으로 최적화 되게 구현합니다. 자신의 구현체를 업그레이드를 하여도 서블릿 표준 인터페이스(API)로
 	응용프로그램 개발자들은 개발하므로 업그레이드가 용이하다. 즉 유지보수성이 높다.
 3. 벤더 독립성 및 이식성
 	이러한 서블릿 웹 아키텍쳐 구조 덕분에 특정 WAS에서 개발된 웹 어플리케이션은 다른 WAS에서도 큰 수정 없이
 	동작할 수 있는 이식성(Portability)을 가집니다
 	기업은 특정 벤더에 종송되지 않고, 필요에 따라 다양한 WAS 제품을 선택하거나 변경할 수 있는 유연성을 확보 할 수 있습니다.
 4. 웹 응용 프로그램 개발 생산성 향상
 	다양한 WAS 제품군들과 관계 없이 표준화된 방법으로 웹 개발이 가능
 	
 	
****서블릿 라이프 사이클 Servlet LifeCycle ****
 - IOC 디자인 패턴 : Spring에서 자세히 다룰 예정
 				  Inversion Of Control (제어의 역전)
 				  -> 객체가 필요로 하는 다른 객체(의존성)을 생성해서 사용하는 것이 아니라
 				  	 외부(컨테이너, 프레임워크)등에서 객체를 대신 생성하여 필요할 때 주입해주는 방식을 말함
 
 웹 컨테이너가 서블릿 객체의 클래스 로딩, 객체 생성, 초기화(init()), 서비스 실행(service()), 소멸(destory())를
 담당함
 
 서블릿은 개발자가 직접 객체를 생성하거나 소멸시키지 않고 웹 컨테이너에 의해 그 생명주기가 전적으로 관리된다(IOC)
 -> 자신이 생성했기에 자신이 직접 웹 컨테이너를 건드려서 관리를 한다.
 
 서블릿 생명주기 Servlet LifeCycle
 init() : 스타벅스 매장 개업 준비 (인테리어, 직원 교육, 메뉴 준비)
 service() : 손님에게 커피 서비스 (주문받고 요리하고 손님 부르고)
 destory() : 매장 폐업 (정리, 직원 정산, 임대 반납)
 - 참고 : Spring의 Bean LifeCycle에 동일한 개념이 적용
 		 @PostConstruct, @PreDestroy 가 서블릿의 init() 과 destory()와
 		 같은 역할을 함
 
 
 - Servlet LifeCycle 상세분석
 1단계 : 서블릿 클래스 로딩 및 객체생성(class loading & Instantiation)
 		client가 브라우저에 요청 -> Web Container가 해당 서블릿 클래스를 loading
 							 -> 인스턴스 생성(단 한번 생성 -> Singleton Pattern)
 2단계 : 초기화 단계로(Initialization)
 		public void init() or public void init(ServletConfig config)
 		인스턴스 생성 직후 - 단 한번 실행
 		서블릿 서비스 전 필요한 초기 작업 수행(설정 정보, 파일, DB 로딩등)
 3단계 : 서비스(Service)
 			protected void service(HttpServletRequest request, HttpServlet Response response){
 			}
 			---dispatch(위임)--> Http Request Method에 따라 -> doGet(request,response)or doPost(request,response)등
 			매 요청시 실행
 			멀티 스레드 환경에서 동시에 실행 가능
 			실제 웹 서비스를 하는 매서드(로그인, 구매, 검색등)
 4단계 : 소멸(destruction)
 		  public void destory(){}
 		  서블릿 언로드 또는 WAS(Web Container) 종료 직전 단 한번 실행(캐시 정리, 파일 닫기, DB 연결 해제 등)
 		  
 
 ***ServletConfig & ServletContext***
 - ServletConfig
 	서블릿 설정 정보 객체
 	서블릿 객체당 하나 생성
 	ServletContext의 주소값을 저장하고 있다.
 	웹컨테이너에 의해 서블릿 초기화 init(ServletConfig config) 시점에 호출되어
 	ServletConfig 객체가 전달
 	구체적으로 어떤 설정 정보인가? ex) SpringMVC에서 DispatcherServlet이 초기화 되는 시점에
 	init 메서드를 웹컨테이너가 호출하여 ServletConfig 객체를 전달하는데 그 안에는 Spring 설정정보가
 	저장되어 전달된다.
 
 - ServletContext
 웹어플리케이션 당 하나 생성
 웹어플리케이션 내 모든 서블릿과 jsp들이 공유하여 사용할 수 있는 객체
 Web Application이 시작 시점에 ServletContext 객체 생성되고
 Web Application 소멸 직전에 ServletContext 객체는 소멸된다
 구체적으로 어떤 곳에서 사용되는가? 웹 어플리케이션 전체 설정 관리
 									  각각의 서블릿(jsp 포함) 간 데이터 공유 지원
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   ***********서블릿 공부시 재사용할 코드**************

// 응답시 컨텐트 타입을 설정, 브라우저에서 지금 응답은 HTML 문서야 라고
		// 메세지를 보내기 위함
		response.setContentType("text/html;charset=UTF-8");
		// HTML을 브라우저로 전송하기 위한 출력 스트림
		PrintWriter out = response.getWriter();
		out.println("<html>");
		out.println("<head>");
		out.println("<title>Servlet Study</title>");
		out.println("</head>");
		out.println("<body>");
		out.println("<h3>Hello Servlet</h3>");
		out.println("</body>");
		out.println("</html>");
		out.close();
 
 